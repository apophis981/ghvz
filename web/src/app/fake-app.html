<dom-module id="ghvz-fake-app">
<script>
  // Not sure why this HTMLImports.whenReady is really needed.
  // Something about polymer initialization order.
  // I think we're not supposed to need this.
  HTMLImports.whenReady(() => {
    Polymer({
      is: 'ghvz-fake-app',

      properties: {
        env: String,

        bridge: {
          type: Object,
        },

        userOptions: Array,

        alreadyReadUrl: {
          type: Boolean,
          value: false,
        },

        appsByUserId: {
          type: Object,
          value: () => ({}),
        },

        focusedUserId: {
          type: String,
          value: undefined,
        },
      },

      listeners: {
        'ghvz-replace-url': 'replaceUrl_',
        'ghvz-push-url': 'pushUrl_',
      },

      pushUrl_(e) {
        this.setUrl_(false);
      },

      replaceUrl_(e) {
        this.setUrl_(true);
      },

      setUrl_(replace) {
        let currentPage = this.appsByUserId[this.focusedUserId];

        let queryParams = Utils.getUrlQueryParameters();
        // Update user in url to be correct
        let focusedOptionIndex = this.userOptions.findIndex((option) => option.userId == this.focusedUserId);
        queryParams.user = this.userOptions[focusedOptionIndex].name;

        // Assemble new URL
        let newUrl = '/' + currentPage.path.join('/');
        let queryString = '';
        for (let key in queryParams) {
          queryString += (queryString ? '&' : '?');
          queryString += key + '=' + queryParams[key];
        }
        newUrl += queryString;

        if (replace)
          window.history.pushState({}, "", newUrl);
        else
          window.history.replaceState({}, "", newUrl);
      },

      getQueryString_() {
        let queryStringMatch = /\?(.*)/.exec(window.location.href);
        if (queryStringMatch)
          return queryStringMatch[1];
        return null;
      },

      attached() {
        window.onpopstate = this.handlePopState_.bind(this);

        let idGenerator = new FakeIdGenerator();

        this.userOptions = [
          {loaded: false, focused: false, url: '', name: 'reggie', userId: FAKE_USER_IDS.reggieUserId, description: 'Registered, not admin, not joined'},
          {loaded: false, focused: false, url: '', name: 'minny', userId: FAKE_USER_IDS.minnyUserId, description: 'Registered, admin, not joined'},
          {loaded: false, focused: false, url: '', name: 'zella', userId: FAKE_USER_IDS.zellaUserId, description: 'Registered, admin, joined, human'},
          {loaded: false, focused: false, url: '', name: 'deckerd', userId: FAKE_USER_IDS.deckerdUserId, description: 'Registered, admin, joined, undeclared'},
          {loaded: false, focused: false, url: '', name: 'moldavi', userId: FAKE_USER_IDS.moldaviUserId, description: 'Registered, admin, joined, human, is keeper of the owls'},
          {loaded: false, focused: false, url: '', name: 'drake', userId: FAKE_USER_IDS.drakeUserId, description: 'Registered, not admin, joined, zombie'},
          {loaded: false, focused: false, url: '', name: 'zeke', userId: FAKE_USER_IDS.zekeUserId, description: 'Registered, not admin, joined, zombie'},
          {loaded: false, focused: false, url: '', name: 'jack', userId: FAKE_USER_IDS.jackUserId, description: 'Registered, not admin, joined, human'},
        ];

        this.bridge =
            new Bridge(
                idGenerator,
                new FakeBridge(
                    idGenerator,
                    new BatchedPolymerWriter(this, 'database')));

        let populate = Utils.getParameterByName('populate', 'light');
        assert(populate == 'light' || populate == 'heavy' || populate == 'none', "populate must be light, heavy, or none");
        if (populate != 'none') {
          populateUsers(this.bridge, FAKE_USER_IDS);
          populateGame(this.bridge, FAKE_USER_IDS, populate == 'heavy');
        }

        this.navigateFromUrl_();
      },

      handlePopState_(e) {
        this.navigateFromUrl_();
      },

      navigateFromUrl_() {
        let userName = Utils.getParameterByName('user', 'zella');
        let userOption = this.userOptions.find((option) => option.name == userName);
        if (userOption) {
          let pathString = window.location.pathname;
          // Strip any slash at beginning or end
          pathString = pathString.startsWith('/') ? pathString.slice(1) : pathString;
          pathString = pathString.endsWith('/') ? pathString.slice(0, pathString.length - 1) : pathString;
          let path = pathString ? pathString.split('/') : [];
          this.loadUser_(userOption.userId, path);
        }
      },

      loadUserTapped_(e) {
        this.loadUser_(e.model.option.userId, []);
      },

      loadUser_(userId, path) {
        let optionIndex = this.userOptions.findIndex((option) => option.userId == userId);
        let option = this.userOptions[optionIndex];

        if (option.focused) {
          this.appsByUserId[this.focusedUserId].setPath_(path);
          return;
        }

        if (this.focusedUserId != null) {
          let focusedOptionIndex = this.userOptions.findIndex((option) => option.userId == this.focusedUserId);
          this.set('userOptions.' + focusedOptionIndex + '.focused', false);
          this.appsByUserId[this.focusedUserId].style.display = 'none';
        }
        if (!option.loaded) {
          let app = document.createElement('ghvz-app');
          app.bridge = this.bridge;
          app.path = path;
          app.userId = userId;
          app.id = option.name + "App";
          this.appsByUserId[userId] = app;
          this.$.apps.appendChild(app);
        }
        this.appsByUserId[userId].style.display = 'block';

        if (option.loaded) {        
          this.appsByUserId[this.focusedUserId].setPath_(path);
        }
        this.set('userOptions.' + optionIndex + '.loaded', true);
        this.set('userOptions.' + optionIndex + '.focused', true);
        this.focusedUserId = userId;

        this.setUrl_(false);
      },

      unloadUserTapped_(e) {
        let option = e.model.option;
        let userId = option.userId;
        let optionIndex = this.userOptions.indexOf(option);

        if (this.focusedUserId == userId) {
          this.focusedUserId = null;
        }

        this.appsByUserId[userId].remove();
        delete this.appsByUserId[userId];
        this.set('userOptions.' + optionIndex + '.focused', false);
        this.set('userOptions.' + optionIndex + '.loaded', false);
      },
    });
  });
</script>
<style>
  :host {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
  }
  #options {
    display: flex;
    padding: 2px;
    position: relative;
    background-color: #add8e6;
  }
  .option {
    height: 24px;
    display: flex;
    align-items: center;
  }
  paper-button {
    background-color: #03A9F4;
    color: white;
    padding: 0;
  }
  .option[focused] paper-button {
    background-color: black;
  }
  paper-icon-button {
    width: 24px;
    height: 24px;
    padding: 0;
    margin-right: 8px;
  }
  #apps {
    flex-grow: 1;
    position: relative;
  }
</style>
<template>
  <div id="apps"></div>
  <div id="options">
    <template is="dom-repeat" items="[[userOptions]]" as="option">
      <div>
        <div class="option" focused$="[[option.focused]]">
          <paper-button
              raised
              id$="[[option.name]]Button"
              on-tap="loadUserTapped_">
            [[option.name]]
          </paper-button>

          <paper-icon-button
              hidden$="[[!option.loaded]]"
              icon="icons:close"
              on-tap="unloadUserTapped_">
          </paper-icon-button>
        </div>
        <!--
        These tooltips seem to interfere with webdrivers...
        <paper-tooltip fit-to-visible-bounds position="top">
          [[option.description]]
        </paper-tooltip> -->
      </div>
    </template>
  </div>
</template>
</dom-module>
