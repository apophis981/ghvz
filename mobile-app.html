
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/iron-icon/iron-icon.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/iron-icons/iron-icons.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/paper-button/paper-button.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/paper-icon-button/paper-icon-button.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/paper-input/paper-input.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/paper-header-panel/paper-header-panel.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/neon-animation/neon-animated-pages.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/neon-animation/neon-animatable.html">
<link rel="import" href="https://cdn.rawgit.com/download/polymer-cdn/1.7.0.2/lib/neon-animation/neon-animations.html">

<link rel="import" href="mobile-login-page.html"/>
<link rel="import" href="mobile-main-page.html"/>
<link rel="import" href="mobile-me-page.html"/>

<dom-module id="mobile-app">
  <script>
    // All scripts should happen when imports are ready.
    // TODO(verdagon): I think we're not supposed to need this...
    HTMLImports.whenReady(() => {
      // Calling Polymer will define our own component. Component is a fancy
      // name for "Element with a bunch of listeners and properties attached".
      Polymer({
        // This means, "Any <mobile-app> tag that ever appears should be
        // managed by the things I'm defining in this Polymer() call."
        // This better match the 'id' attribute in the above <dom-module>.
        is: 'mobile-app',

        // Member variables for our element. These are added to the actual
        // element, so make sure not to use any of html's built-in property
        // names like 'id', 'name', 'src', or anything. Also avoid anything
        // starting with 'on'.
        properties: {
          // Instance of a class we made for communicating with our server.
          // See remoteserverbridge.js.
          bridge: {
            type: Object,
            value: new FakeServerBridge(),
          },

          localStorage: {
            type: Object,
            // When value is a function, that actually means "execute this
            // function to get the initial value."
            value: function() {
              // Browser's persistent key-value store. See
              // https://developer.mozilla.org/docs/Web/API/Window/localStorage
              // We use it to remember the user's last email and password.
              var ls = window.localStorage;
              // Since we dont have a real server yet
              ls.setItem('rememberedEmail', 'fakeuser@gmail.com');
              ls.setItem('rememberedAuthCode', '123456');
              return ls;
            },
          },
        },

        // If our element has a created method, polymer calls it when our
        // element is first created. However, this happens before any of our
        // properties are initialized, so the created() method is generally
        // not as useful as attached().
        created: function() {
        },

        // If our element has an attached method, polymer calls it when our
        // element is finally added to the document.
        // All property bindings via html will have already happened (such as
        // bridge in <my-element bridge="[[bridge]]">...</my-element>).
        // attached usually accomplishes the same things a constructor would.
        attached: function() {
          this.showLoginPage_();

          if (this.localStorage.getItem('rememberedEmail')) {
            this.bridge.login(
                this.localStorage.getItem('rememberedEmail'),
                this.localStorage.getItem('rememberedCode'))
                .then(() => {
                  this.showMainPage_();
                });
          }
        },

        // Shorthand for listening to events. We could have just as easily have
        // said (in our attached method preferably) something like this:
        // this.addEventListener(
        //     'mobile-me-page-back', this.showMainPage_.bind(this));
        listeners: {
          'mobile-main-page-show-me-page': 'showMePage_',
          'mobile-me-page-back': 'showMainPage_',
          'mobile-login-page-logged-in': 'showMainPage_',
        },

        // Below this line is our own private methods. Our convention is to
        // suffix them with an underscore.

        showLoginPage_: function() {
          // this.$ is an object populated with all the ID'd elements inside
          // us. It's as if we said this.getElementById('loginPage').
          this.$.pages.entryAnimation = '';
          this.$.pages.exitAnimation = '';
          // When the <neon-animated-pages> element sees its selected property
          // change, it uses entryAnimation and exitAnimation and animates
          // from the old selected page to the new selected page.
          this.$.pages.selected = 0;
          // IMO, polymer should have made a method that we could call like
          //     pages.switchPage(0, '', 'slide-right-animation')
          // but polymer's components are very property-happy.

          this.$.loginPage.startedShowing();
        },

        showMainPage_: function(e) {
          if (this.$.pages.selected == 0) {
            // If we were just looking at the login page, then slide in
            // the main page from the right.
            this.$.pages.entryAnimation = 'slide-from-right-animation';
            this.$.pages.exitAnimation = '';
          } else {
            // If we came from somewhere else, slide out whatever it was to
            // the right.
            this.$.pages.entryAnimation = '';
            this.$.pages.exitAnimation = 'slide-right-animation';
          }
          this.$.pages.selected = 1;
          this.$.mainPage.startedShowing();
        },

        showMePage_: function(e) {
          this.$.pages.entryAnimation = 'slide-from-right-animation';
          this.$.pages.exitAnimation = '';
          this.$.pages.selected = 2;
          this.$.mePage.startedShowing();
        },
      });
    });
  </script>
  <template>
    <style>
      /* In a dom-module, all of our css rules are sandboxed; no CSS defined
         here will affect anything else on the page. That's why it's safe to
         use very general rules like below. */

      /* :host just means "this element" */
      :host {
        --toolbar-theme: {
          background-color: #03a9f4;
          color: white;
          font-size: 16px;
          line-height: 48px;
        };
        width: 100%;
        height: 100%;
      }
      neon-animated-pages {
        width: 100%;
        height: 100%;
      }
      neon-animatable {
        width: 100%;
        height: 100%;
        background-color: white;
      }
    </style>

    <!-- <neon-animated-pages> requires its selected, entry-animation, and
      exit-animation attributes to be set. You'd often see something like:
      <neon-animated-pages
          id="pages"
          class="flex"
          entry-animation="slide-from-left-animation"
          exit-animation="slide-right-animation"
          selected="0">
      but we set those manually via javascript. -->
    <neon-animated-pages id="pages" class="flex">
      <neon-animatable>

        <!-- The [[bridge]] is a special Polymer thing meaning:
          "The target element (in this case, <mobile-login-page>) has a
          property named 'bridge'. After constructing but before attaching this
          new <mobile-login-page> element to us, please set its bridge property
          to our own 'bridge' property. Also, if our bridge property changes,
          please change <mobile-login-page>'s bridge property as well." -->
        <mobile-login-page id="loginPage" bridge="[[bridge]]"></mobile-login-page>

      </neon-animatable>
      <neon-animatable>

        <mobile-main-page id="mainPage" bridge="[[bridge]]"></mobile-main-page>

      </neon-animatable>
      <neon-animatable>

        <mobile-me-page id="mePage" bridge="[[bridge]]"></mobile-me-page>

      </neon-animatable>
    </neon-animated-pages>

  </template>
</dom-module>